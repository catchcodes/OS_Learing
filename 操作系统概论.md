<div align="center"><span style="color: #a1a1a1; font-size: x-large;">目录</span></div>

[TOC]

<center style="color: #090909; font-size: 25px; background-color: #fffafa;">正文</center>

# 一、操作系统概论

## 要点

（1） 操作系统的发展历史、定义、作用、功能、特征、分类、发展动力和研究动向；
（2） 操作系统在计算机系统中的地位，以及与其他软件的联系与区别；
（3） 操作系统的**资源管理技术**：==复用、虚拟和抽象==；
（4） 操作系统**三个最基本抽象**：==进程抽象、虚存抽象和文件抽象==；
（5） 操作系统虚拟机及其实现原理；
（6） 多道程序设计定义、实现基础、基本原理、主要特征。
（7） 程序接口与系统调用；
（8） 操作接口与系统程序；
（9） 操作系统内核、功能及属性；
（10） 操作系统的运行模式及其分类；

## 计算机系统

**计算机系统**：由**硬件**和**软件**相互交织形成的集合体，构成一个解决计算问题的工具

**硬件**：计算机物理装置本身，可以是电子的、磁的、机械的、光的元件或装置

**软件**：指计算机系统中的所有软件，包括系统软件、（支撑软件+操作系统 = 系统软件）、应用软件

- **系统软件**：主要指用来运行或控制硬件所开发的计算机软件，如==操作系统、解释器、编译器、数据库管理系统、硬件驱动程序==等面向开发者的软件。（系统软件也特指操作系统，支撑软件为其他）
- **应用软件**，简称应用（application或app），是软件的主要分类，指为针对用户的某种特殊应用目的所撰写的程序，例如文本处理器、表格、会计应用、浏览器、媒体播放器、航空飞行模拟器、命令行游戏、图像编辑器等

硬件是软件运行的物质基础，软件能够充分地发挥硬件潜能并扩充其功能，完成各种应
用任务，两者互相促进，相辅相成，缺一不可。

<div align="center"><img src="../_resources/屏幕截图%202023-05-08%20143331.png" width="350" class="jop-noMdConv"></div><div align="center"><img src="../_resources/6c456fec160464fd4852ba5ae434f1a6.png" width="350" class="jop-noMdConv"></div>

## 操作系统

<span style="color: #f08080; font-size: 1.2em;">资源</span>：能分配给用户使用的硬件和软件设施总称为资源，包括两类：硬件资源和信息资源。

- 硬件资源：处理器、存储器、I/O设备等；
- 信息资源：程序和数据等。

OS是<span style="color: #f4a460; font-size: 1.2em;">资源管理</span>者，**管理内容**：
1、资源的当前状态（数量和使用情况）
2、资源的分配、回收和访问操作
3、相应管理策略（包括用户权限）

<div align="center"><img src="../_resources/994dea5ee640165f327782df2455bf15.png" width="350" class="jop-noMdConv"></div>

<span style="color: #20a0d0; font-size: 1.1em;">主要特性</span>：
**并发性**：

> 并发指两个或两个以上的事件或活动在同一时间间隔内发生（不一定同时执行）；
> 并行指两个或两个以上的事件或活动在同一时刻发生（同时执行）。
> 并行的事件或活动一定是并发的，但反之并发的事件或活动未必是并行的

**共享性**：

> 指操作系统中的资源可被多个并发执行的进程所使用

**异步性**：

> 指系统中的各种事件的发生具有随机性。
> 异步性给系统带来潜在危险，有可能导致与时间有关的错误

**OS资源管理技术**：

- ==资源复用==：解决物理资源数量不足
  
  - 空分复用
  - 时分复用
    - 时分独占性，通常使用一个完整的周期后才会释放(如磁带)
    - 时分共享性，可能随时被剥夺，被另一个进程抢占使用(如处理器、磁盘机)

- ==资源虚拟==：解决物理资源数量不足 ，提高服务的能力和水平
  
  > 资源转化、模拟或整合技术，可将物理上的一个资源变成逻辑上的多个对应物(或物理上多个变成逻辑上一个)

- ==资源抽象==：处理系统的复杂性，解决资源的易用性
  
  > 资源抽象指通过创建软件来屏蔽硬件资源的物理特性和接口细节，简化对硬件资源的操作、控制和使用的一类技术
  
  - 三个基础抽象：进程（处理器的抽象）、虚存（内存的抽象）、文件（I/O设备的抽象）

<span style="color: #ff6347;">**系统调用与系统程序**</span>：

- 系统调用

系统调用本质是异常

<div align="center"><img src="../_resources/93e6d92ebb2bf5651540239d8ca7a8fe.png" width="350" class="jop-noMdConv"></div>系统调用是应用程序获得**操作系统服务**的唯一途径

- 系统程序

**系统程序**又称实用程序或支撑程序（Utilities），虽非操作系统的核心，但却必不可少，为用户程序的开发、调试、执行、和维护解决带有共性的问题或执行公共操作

**系统调用**功能分类

- 进程和作业管理：
- 文件操作：
- 设备管理：
- 主存管理：
- 信息维护：
- 进程通信

**系统程序**分类：

- 文件管理
- 状态信息
- 程序设计语言支持
- 程序的装入和执行支持
- 通信
- 其它软件工具

<span style="color: #ff6347;">**单内核和微内核**：</span>
**单内核**：
将内核从整体上作为一个大进程实现，并同时运行在一个单独的地址空间。所有的内核服务都在一个地址空间运行，相互之间直接调用函数，简单高效。

除了最基本的进程、线程管理、内存管理外，文件系统，驱动，网络协议等等都在内核里面。优点是效率高。缺点是稳定性差

**微内核**：
微内核考虑在操作系统的内核中保留操作系统最基本的功能，也就是任务调度、内存和设备的抽象和管理。其他的功能全部从内核移出，放到用户态中了实现，并以C/S模式对其他应用程序提供服务。

微内核带来的好处主要是稳定性和实时性，即内核中模块数量少了，结构更精简更优化了，能够影响内核的程序和驱动也减少了，稳定性随之提高；另外就是实时性，内核精简了以后，响应的时延的减小。不过并不是精简了以后会使得性能提升，微内核使得内核中只有最关键的部分，其他模块和系统功能全部作为独立模块放到用户态空间中运行，功能分散了以后增加了通信的成本。

<span style="color: #ff6347;">**多道程序设计**</span>：
多道程序设计指允许多个程序（作业）同时进入一个计算机系统的内存并启动交替计算的方法。

优点
 提高了CPU的利用率;
 提高了主存和I/O设备的利用率;
 改进了系统的吞吐率;
 充分发挥了系统的并行性。
缺点
 作业周转时间延长

实现多道程序设计须解决三个问题：
 存储保护与程序浮动；
 处理器的管理和调度；
 系统资源的管理和调度。

# 二、处理器管理

## 要点

（1） 可重入程序和可再用程序；
（2） 为什么要引入进程？进程的定义和属性、进程的状态和转换、进程的描述和组成、进程上下文；
（3） 进程切换、切换时机和切换过程、处理器状态转换；
（4） 为什么要引入线程？多线程环境中进程与线程联系和区别、线程的实现（内核级线程和用户级线程）
（5） 处理器状态及其转换、特权指令与非特权指令、程序状态字；
（6） 处理器调度的层次；处理器调度算法选择的准则；
（7） 作业调度和低级调度算法；

## 内核态与用户态

### 特权指令

特权指令是指只能提供给操作系统的核心程序使用的指令，如：
<span style="color: #f4a460;">启动I/O设备、设置时钟、控制中断屏蔽位、清主存、建立存储键，加载PSW（程序状态字、标志寄存器）等</span>

### 非特权指令

<span style="color: #ff6347;">存取数，读时钟，加减乘除，寄存器清零，压栈弹栈，跳转，trap（访管）</span>

PSW用来控制指令执行顺序并保留和指示与程序有关的系统状态，主要作用是实现程序状态的保护和恢复，PSW记录当前程序运行的动态信息（程序基本状态、中断字、中断屏蔽位）

处理器通过*处理器状态标志*知道当前是操作系统还是一般用户程序在运行

处理器状态标志：管理状态（核心状态、特态或管态）和用户状态（目标状态、常态或目态)，是PSW的一位。

中断和异常（内中断 **陷入**）是用户态到内核态转换仅有的途径

<div align="center"><img src="../_resources/b1680dd9f919ce4662e2a51e502cc989.png" width="350" class="jop-noMdConv"></div>

中断（广义，外中断和异常）是激活操作系统的唯一方式。
中断是指程序执行过程中，遇到急需处理的事件时，暂时中止CPU上现行程序的运行，转去执行相应的事件处理程序，待处理完成后再返回原程序被中断处或调度其他程序执行的过程
 发现中断源；
 保护现场；
 转向处理中断/异常事件的处理程序；
 恢复现场。

## 进程

### 基本概念

> 进程是可并发执行的程序在某个数据集合上的一次计算活动，也是操作系统进行**资源分配和保护的基本单位**

1、刻画程序的并发性
2、解决资源的共享性
可再用程序：在调用它的程序退出之前不允许其他程序调用的程序
可再入程序：能够被多个程序同时调用的程序
程序的可再入性使程序与程序的执行不再一一对应

<span style="color: #f08080;">属性</span>：

- 动态性：进程是程序在数据集合上的一次**执行过程**，是动态概念
- 共享性：同一程序同时运行于不同数据集合上时，构成不同的进程
- 独立性：资源分配和保护的基本单位，每个进程的**地址空间相互独立**。调度的基本单位是线程
- 制约性：并发进程之间存在着制约性，在进行的关键点上需要相互等待或互通消息
- 并发性：各进程按各自独立的、不可预知的速度并发推进

### 进程状态

#### 三态模型

<div align="center"><img src="../_resources/4694475ba3368186a0cd4f8ddfbb5476.png" width="350" class="jop-noMdConv"></div><span style="color: #f4a460;">运行(Running)态</span>：进程占有CPU，并在CPU上运行。 处于此状态的进程的数目小于等于CPU的数目

<span style="color: #f4a460;">就绪(Ready)态</span>：进程已获得除处理机外的所需资源，等待分配处理机资源；只要分配CPU就可执行。
可以按多个优先级来划分队列，如：时间片用完－>低优，I/O完成－>中优，页面调入完成－>高优

<span style="color: #f4a460;">等待(Blocked，阻塞)态</span>：指进程因等待某种事件的发生而暂时不能运行的状态（即使CPU空闲，该进程也不可运行）。
等待的事件可以为：I/O操作或进程同步等

就绪—》运行：调度程序选择一个新的进程运行。该转换可以由其他转换引起。

运行—》就绪：运行进程**用完了时间片**；运行进程被中断，因为一**高优先级进程处于就绪状态**。该转换可以引起其他转换发生。

运行—》等待：当一进程必须**等待某事件发生**。该转换可以引起其他转换发生。
OS尚未完成服务
对一资源的访问尚不能进行
初始化I/O 且必须等待结果
等待某一进程提供输入 (IPC)

等待—》就绪：当**所等待的事件发生**时

<span style="color: #40e0d0;">因果变迁</span>：如果一个状态变迁是由于另一个状态变迁引起的，则这两个变迁为因果变迁

#### 五态模型

<div align="center"><img src="../_resources/87b53e84ba012a13b2bef4d450820b12.png" width="450" class="jop-noMdConv"></div><span style="color: #f4a460;">新建态</span>：进程正在创建，尚未转到就绪状态。新建过程：1.为新进程分配所需要的资源和建立必要的管理信息。2.设置该进程为就绪态，并等待被调度执行

<span style="color: #f4a460;">终止态</span>：进程正在从系统中结束，原因可能是正常退出，也可能是异常退出

#### 七态模型

加入挂起状态：

<div align="center"><img src="../_resources/e5cbbbc53ce08e1537c930b5f96e31d1.png" width="450" class="jop-noMdConv"></div>当系统资源尤其是**内存资源已经不能满足进程运行的要求**时，必须把某些进程挂起（suspend），对换到磁盘对换区中，释放它占有的某些资源，暂时不参与低级调度。起到**平滑系统操作负荷**的目的。

进程进入挂起状态是由于操作系统、父进程或进程本身阻止它的运行

### 进程组成

进程映像：

- 进程控制块PCB ，是操作系统用于记录<span style="color: #f08080;">进程标志信息、现场信息和控制信息</span>的数据结构
- 进程程序块，被进程执行的程序
- 进程核心栈，用来保存中断/异常现场，保存函数调用的参数、局部变量和返回地址
- 进程数据块，进程的私有地址空间，存放各种私有数据，包括用户栈

进程上下文：进程物理实体和支持进程运行的环境
 用户级上下文：由程序块、数据块、共享内存区、用户栈组成，占用进程的虚存空间。
 系统级上下文：有进程控制块、内存管理信息、核心栈等操作系统管理进程所需要的信息组成。
 寄存器上下文：由处理器状态寄存器、指令计数器、栈指针、通用寄存器等组成。

进程队列：处于同一状态的所有PCB链接在一起的数据结构称为进程队列

原语是在管态下执行、完成系统特定功能的过程。执行过程中不允许被中断，是一个不可分割的基本单位，原语的执行是顺序的而不可能是并发的

## 线程

多进程：时间空间开销大，限制并发度的提高

引入线程的目的：
 减小（进程/线程）上下文切换开销；
 更好支持多处理器（MP），达到最大程度的并行 ；
 简化进程间的通信。

操作系统中引入进程的目的是为了使多个程序并发执行，以改善资源使用率和提高系统效率，

操作系统中再引入线程，则是为了减少程序并发执行时所付出的时空开销，使得并发粒度更细、并发性更好。

进程作为系统<span style="color: #f08080;">资源分配和保护</span>的独立单位
线程作为系统<span style="color: #f08080;">调度和分派的基本单位</span>。

<div align="center"><img src="../_resources/bc23471e72076a25b229f94dd2481608.png" width="450" class="jop-noMdConv"></div>

<span style="color: #ff6347;">用户级线程ULT</span>：由用户应用程序建立、调度和管理的线程
优点
 线程切换不调用内核
 调度是应用程序特定的：可以选择最好的算法。
 ULT可运行在任何操作系统上（只需要线程库）。

缺点
 大多数系统调用是阻塞的，因此核心阻塞进程，故进程中所有线程将被阻塞。
 核心只将处理器分配给进程，同一进程中的两个线程不能同时运行于两个处理器上。

<span style="color: #ff6347;">内核级线程KLT</span>：由操作系统的内核建立、调度和管理的线程
优点：
 对多处理器，内核可以同时调度同一进程的多个线程
 阻塞是在线程一级完成
 内核例程是多线程的

缺点：
 在同一进程内的线程切换调用内核，导致速度下降

## 处理机调度

### 三级调度

<div align="center"><img src="../_resources/e4ed9edda75a2110cd8e973b2d55dccd.png" width="450" class="jop-noMdConv"></div>

### 二级调度

<div align="center"><img src="../_resources/3faf7dd817faae2dd6bf65c1083f3704.png" width="450" class="jop-noMdConv"></div>

### 作业管理与调度

作业是任务实体，进程是完成任务的执行实体。

交互式进程从提交一个请求(命令)到接收到响应之间的时间间隔称响应时间。

批处理用户从作业提交给系统开始，到作业完成为止的时间间隔称**作业周转时间**，是作业在系统里的等待时间与运行时间之和。

多道批处理操作系统具有独立的作业管理模块，必须像进程管理一样为每一个作业建立作业控制块（JCB）
JCB的主要内容包括：
作业情况
资源需求
资源使用情况

如果作业$i$提交给系统的时刻是$t_s$ ,完成时刻是$t_f$，该作业的周转时间$t_i$为：$t_i = t_f - t_s$

如果作业$i$的周转时间为$t_i$，所需运行时间为$t_k$，则称$\displaystyle w_i=\frac{t_i}{t_k}$为该作业的带权周转时间。

**调度算法**：

1. 先来先服务算法FCFS：平均作业周转时间与作业提交的顺序有关
2. 最短作业优先算法SJF：选取估计计算时间最短的作业投入运行，忽视了作业等待时间，会出现饥饿现象
3. 最短剩余时间优先算法SRTF：把SJF算法改为抢占式的
4. 最高响应比优先算法HRRF：既考虑作业等待时间，又考虑作业的运行时间。
   **响应比 ＝1+已等待时间/估计运行时间**
5. 优先级调度算法：静态优先数法；动态优先数法
6. 时间片轮转调度算法
7. 多级反馈队列调度：主要思想是将就绪进程分为两级或多级，系统相应建立两个或多个就绪进程队列，较高优先级的队列一般分配给较短的时间片。
   处理器调度先从高级就绪进程队列中选取可占有处理器的进程，只有在选不到时，才从较低级的就绪进程队列中选取

<div align="center"><img src="../_resources/26552bae3db5e134e765c801b8afb390.png" width="400" class="jop-noMdConv"></div>

# 三、同步与死锁

## 要点

（1） 程序的顺序执行与并发执行；
（2） 与时间有关错误、相交和不相交并发进程；
（3） 进程互斥、临界区、临界资源、竞争条件、临界区管理的实现方法(硬件设施和软件算法)；
（4） 进程的竞争和协作；
（5） 进程同步、同步机制、用信号量和PV操作解决经典同步问题；
（6） 死锁定义、引发原因、产生条件、死锁防止、避免、检测及解除方法

## 进程的交往：竞争与协作

并发进程的无关性是进程的执行与时间无关的一个充分条件，又称为Bernstein条件

与时间有关错误有两种表现形式：
 结果不唯一
 永远等待

### 竞争

**竞争关系**： 指原本不存在逻辑关系的诸进程因共享资源而产生的交互和制约关系

资源竞争的两个控制问题：
 死锁(Deadlock)问题：进程因争夺资源陷入永久等待的状态；
 饥饿(Starvation) 问题：进程对资源的使用被无限期拖延或超过等待时间的上届。

进程互斥：指若干个进程因相互争夺独占型资源时所产生的竞争制约关系

### 协作

协作关系：指某些进程为完成同一任务需要分工协作而产生的关系

**进程同步**：指为完成共同任务的并发进程基于某个条件来协调它们的活动，因为需要在某些位置上排定执行的先后次序而等待、传递信号或消息所产生的协作制约关系

### 临界区管理

临界区：并发进程中与共享变量有关的程序段
临界资源：共享变量代表的资源
临界区调度原则：
 互斥使用、有空让进，
 忙则等待、有限等待，
 择一而入、算法可行。

软件算法：
Peterson算法

<div align=center>
    <img src="../_resources/443ff24b87549a269d49682fa8182ed3.png" width=500px />
</div>

硬件设施：
关中断（单CPU）；
硬件指令方法（一条机器硬件指令完成读写两个操作，执行时不响应中断）
TS指令的处理过程

```C++
bool TS(bool &x) {
    if(x) {
        x=false;
        return true;
    }
    else
        return false;
}

/*TS指令实现进程互斥*/
bool s=true;
cobegin
process Pi( ) { //i=1,2,...,n
    while(!TS(s)); /*上锁*/
        /*临界区*/;
        s=true; /*开锁*/
}
coend
```

```C++
// SWAP指令的处理过程
void SWAP(bool &a,bool &b) {
    bool temp=a;
    a=b;
    b=temp;
}

bool lock=false;
cobegin
Process Pi( ){ //i=1,2,...,n
    bool keyi=true;
    do {
        SWAP(keyi,lock);
    }while(keyi); /*上锁*/
    /*临界区*/;
    SWAP(keyi,lock); /*开锁*/
}
coend
```

缺点：忙等待、饥饿、需CPU支持

原语： 内核中执行时不可被中断的过程
信号量：一种软件资源， 除初始化外，仅能由两个同步原语对其进行操作的整型变量。

## 死锁

 死锁定义：死锁是指系统中的一组进程，由于竞争系统资源或由于彼此通信而永远阻塞，称这些进程处于死锁状态。

原因：
1、进程竞争资源，而资源不足
2、进程推进顺序不合适
设系统某类资源有m个，有n个进程，每个进程需要K个该资源，则当满足nk<= m+(n-1)时，系统不会引起死锁。

进程因竞争独享、不可抢占资源而发生死锁
死锁**必要条件**：

1. 互斥条件：一个资源一次只能被一个进程所使用。
2. 不可抢占条件：一个资源仅能被占有它的进程所释放，而不能被其他的进程强行抢占
3. 部分分配条件（请求和保持）：一个进程已占有分给它的资源，但仍然要求其他资源
4. 循环等待条件：在系统中存在一个由若干个进程形成的环形请求链，其中的每一个进程均占有若干种资源中的某一种，同时还要求下一个进程所占有的资源

进程-资源分配图：
Pi→Rj为请求边；Rj→Pi为分配边

<div align=center>
    <img src="../_resources/770b8f331e3e671bab7e4a9264a257ba.png" width=300px />
</div>
<div align=center>
    <img src="../_resources/c02ae2436b66e195256c8e54209bc769.png" width=600px />
</div>

### 死锁预防

* 破坏第一个条件（互斥条件）：使资源可同时访问而不是互斥使用，
* 破坏第二个条件（部分分配条件）：采用预先静态分配法（一次分配给其所需的全部资源，若系统不能满足，则进程阻塞，直到系统满足其要求）
* 破坏第三个条件（不剥夺条件）：采用剥夺式调度方法
* 破坏第四个条件（循环等待条件）：采用层次分配策略

### 死锁避免

死锁避免：在分配资源时判断是否会出现死锁，如不会死锁，则分配资源
1）Available向量：系统中可利用的资源数目
2）Max矩阵：每个进程对每种资源的最大需求
3）Allocation矩阵：每个进程已分配的各类资源的数目
4）Need矩阵：每个进程还需要的各类资源数
5）work向量：系统可提供给进程继续运行所需的各类资源数目 work+=Allocation
6）finish：完成标志

### 死锁检测

通过系统设置的检测机构，实际地检查系统中是否存在死锁，并精确地标定出与死锁有关的进程和资源。

在OS中保存资源的请求和分配信息，利用某种算法对这些信息加以检查，以判断是否存在死锁。检测算法主要是检查是否有循环等待。

进程-资源分配图中无环路，则此时系统没有发生死锁
进程-资源分配图中有环路，且每个资源类中仅有一个资源，则系统中发生了死锁

死锁解除：

* 撤销进程并剥夺资源。
* 使用挂起和解除挂起机构
  
  # 四、存储管理

## 要点

（1） 存储器层次、程序名字空间、逻辑地址空间和物理地址空间及其关系；
（2） 地址重定位、存储保护机制；
（3） 分区存储管理：分区原理、分配算法、内存不足解决方法（移动技术、对换技术和覆盖技术）；
（4） 分页存储管理基本概念-页面、页框、逻辑地址、页表和地址转换、快表、页面共享和保护；多级页表；
（5） 分段存储管理基本概念、实现思想及优点；
（6） 虚拟存储器、程序局部性原理；请求分页虚存管理的基本原理、硬件支撑、页表结构、地址转换、缺页中断率计算；
（7） 各种页面替换算法。

## 存储管理

主要功能：主存分配和回收；地址转换和重定位；存储保护和主存共享；存储器扩充

 为什么程序使用逻辑地址而不是物理地址？
 用户需要精确计算空间与存放地址；
 支持多道程序运行十分困难；
 程序的可移植性差。

<div align="center"><img src="../_resources/a00582a84ee10a23b100c7a0e6090f93.png" width="450" class="jop-noMdConv"></div>

内部碎片就是已经被**分配出去**（能明确指出属于哪个进程）却**不能被利用**的内存空间
外部碎片指的是还没有被分配出去（不属于任何进程），但由于**太小了无法分配**给申请内存空间的新进程的内存空闲区域

## 分页存储管理：

<div align=center>
    <img src="../_resources/e19e9b3ec693833ac656e818c28d6f1f.png" width=500px />
</div>

在分页系统中，每个逻辑地址用一个数对表示：（p,d）
其中：p：页号；d：页内偏移地址
逻辑地址A，页大小为 L，则：
p = INT[A/L]；
d = A mod L
逻辑地址2500，页大小1024，则p = 2，d = 452，
逻辑地址可表示为（2，452）
优点

* 主存利用率高，不存在页外碎片，极少页内碎片，存在于每个进程最后页内。
* 主存分配和释放快。
* 分区管理简单。

缺点：

* 要求一次将进程全部页装入主存；
* 存在页内碎片。
  
  <div align=center>
    <img src="../_resources/d20e6e0934a7d2cb0b70631d17a12930.png" width=500px />
  </div>

## 分段管理：

段的定义：一组逻辑信息的集合
采用二维地址空间来表示，
V =（S，W）；
其中， S：段号，W：段内地址

<div align=center>
    <img src="../_resources/be400befba2ed0999e145802a974c67d.png" width=500px />
</div>

<div align=center>
    <img src="../_resources/7fcd4887adaa7e1829ed193c0c92be54.png" width=500px />
</div>

简单分段的特点：
 没有内部碎片；
 便于共享和保护；
 存在外部碎片；
 由于段内连续分配，段的长度受内存空闲区大小的限制；
 需要更多硬件支持

## 虚拟存储器

实存管理需要将作业一次全部内存方能运行，使作业的大小受到内存的极大限制

虚拟存储器：在具有层次结构存储器的计算机系统中，采用自动实现部分装入和部分对换功能，为用户提供一个比物理内存容量大得多的，可寻址的一种“内存储器”

<div align=center>
    <img src="../_resources/4041402e68ebf52a117b9eca5923fcc9.png" width=500px />
</div>
实存中需要将所有页一次装入内存，虚存中只需将部分页装入内存。 在执行过程中访问到不在内存的页面时，产生缺页中断，再从磁盘动态地装入
<div align=center>
    <img src="../_resources/16708e998518ec537bd666af226d828a.png" width=500px />
</div>

<div align=center>
    <img src="../_resources/0dcb942379dfae67e7481abd04d73124.png" width=500px />
</div>

反置页表
反置页表的大小只与物理内存的大小相对关，与逻辑空间大小和进程数无关

请求分页虚存

<div align=center>
    <img src="../_resources/d4229a139f42e7d96112d05aacc5c49f.png" width=500px />
</div>

段页式：

<div align=center>
    <img src="../_resources/61a2b0076bc93065b2e8eeddc481d623.png" width=00px />
</div>

<div align=center>
    <img src="../_resources/3c2882cf3fad1951d77068a53e689370.png" width=500px />
</div>

页式平均每个程序有一页有碎片，段页式则是平均每段有一页有碎片

<div align=center>
    <img src="../_resources/e2589204bea8ec76dbb79efd2b17619e.png" width=500px />
</div>

## 页面管理策略

1、页面装入策略

* 请页式调度：指当进程需要访问某页面时，才将该页调入主存
* 预调式调度：指在进程访问某页面之前，就预先将该页面调入主存

2、页面清除策略

* 请页式清除：仅当一页被选中进行替换且内容被修改过才把它写回磁盘
* 预清除：对所有更改过的页面，在需要替换之前把它们都写回磁盘

3、页面分配策略

* 固定分配：进程保持页框数固定不变
* 可变分配：进程执行的某阶段缺页率较高，说明目前局部性较差，系统可多分些页框以降低缺页率，反之说明进程目前的局部性较好，可减少分给进程的页框数

4、页面置换策略

* 全局替换：页面替换算法的作用范围是整个系统
* 局部替换：页面替换算法的作用范围局限于本进程

5、缺页中断率
假定作业p共计n页，系统分配给它的内存块只有m块（１≤m≤n）。如果作业p在运行中成功的访问次数为s，不成功的访问次数为F，则总的访问次数Ａ为：A = S + F
**缺页中断率**：f = F / A

6、全局页面替换算法

1) 最佳页面替换算法OPT：无法实现，选择“将来不再使用的”或“在最远的将来才被访问的”页面被置换
2) 先进先出页面替换算法FIFO：淘汰最先调入内存的页，或者说在内存中驻留时间最长的页。队列
   Belady现象：采用FIFO算法时，如果对一个进程未分配它所要求的全部页面，有时就会出现增加可用物理页框数量反而会导致缺页率增加的异常现象
   页面缓冲算法
   维护两个FIFO队列：修改页面队列和非修改(空闲)页面队列
3) 最近最少用页面替换算法LRU：淘汰的页面是在最近一段时间里较久未被访问的那页。引用位法（一位标志位，缺页中断后全置0）；计数法（缺页中断后全置0）；计时法（绝对时间）；老化算法（多位寄存器，移位）
4) 第二次机会页面替换算法SCR：FIFO+引用位。最先进入内存的页面，如果最近还在被使用的话，仍然有机会作为像一个新调入页面一样留在内存中
5) 时钟页面替换算法Clock
   SCR中的线性链表-》循环链表
   改进：把“引用位”r和“修改位”m结合起来使用，共组合成四种情况
   步1：选择最佳淘汰页面，从指针当前位置开始,扫描循环队列。扫描过程中不改变“引用位”，把遇的第一个r=0,m=0的页面作为淘汰页面。
   步2：如果步1失败，再次从原位置开始，查找r=0且m=1的页面，把遇到的第一个这样的页面作为淘汰页面，而在扫描过程中把指针所扫过的页面的“引用位”r置0。
   步3：如果步2失败，指针再次回到了起始位置，由于此时所有页面的“引用位”r均己为0，再转向步1操作，必要时再做步2操作，这次一定可以挑出一个可淘汰的页面。

7、局部页面替换算法

1) 局部最佳页面替换算法
   不论发生缺页与否，算法在每一步要考虑引用串，如果该页面在时间间隔(t,t+τ)内未被**再次**引用，那么就移出（用完就丢）；否则，该页被保留在进程驻留集中
2) 工作集模型和工作集置换算法
   进程工作集指“在某一段时间间隔内进程运行所需访问的页面集合”
   根据t-Δ到时刻t之间
3) 模拟工作集替换算法
   为页面设置引用位及关联时间戳，超时中断，周期性地检查引用位及时间戳。引用位为1时，就把它置0，并把这次改变的时间作为时间戳记录下来；引用位为0时系统当前时间减去时间戳时间，超过阈值就移出工作集
4) 缺页频率替换算法
   本次缺页与前次缺页之间的时间超过临界值τ，那么，所有在这个时间间隔内没有引用的页面都被移出工作集

<div align=center>
    <img src="../_resources/37834a87ed85da503ccdaae91fbf9864.png" width=500px />
</div>

# 五、设备管理

## 要点

（1） I/O设备分类；I/O控制方式；设备控制器及其工作原理；
（2） I/O软件层次（I/O中断处理程序、I/O设备驱动程序、独立于设备的I/O软件和用户层I/O软件）及各层的功能；
（3） I/O调度和磁盘驱动调度算法；
（4） 虚拟设备的原理、实现要点。

## 设备

字符设备：输入型外围设备和输出型外围设备一般为字符设备，与内存进行信息交换的单位是字节。如鼠标、键盘、串口、控制台和LED设备

块设备：

- 顺序存取存储设备：只有当前面的存储物理块被存取以后，才能存取后面的物理块，如磁带。
- 直接存取存储设备：对任何一个物理块存取不必进行事先顺序搜索，如磁盘。

对I/O设备的控制方式分类：

- 轮询方式
- 中断方式 ：
    中断驱动方式以字（节）为单位进行数据传送，每完成一个字（节）的传送，控制器产生一次中断。系统需占用CPU进行现场的保存和和恢复
- DMA（直接存储器访问）方式：CPU只需干预I/O操作的开始和结束，而其中
    的一批数据读写无需CPU控制，适于高速设备。在 I/O设备与外设之间有直接数据通路，传送过程中不需要CPU参与，而是 DMA控制器控制完成。
  当 CPU 与 I/O 同时访问主存，CPU 必须把总线占有权让给 DMA 接口使用，即 DMA 采用**周期挪用**占用一个存储周期
- 通道方式：CPU只要向 I/O通道发送一条 I/O指令，哪怕是一组相关的读写操作，通道会执行**通道程序**，完成一组数据的传送。可以控制多台设备与内存的数据进行交换

## 设备控制器

设备控制器：I/O设备的**电子部件**，又称适配器，是可插入主板扩充槽的印刷电路板。
传统的设备=机械部分+电子部分
将电子部分从设备中分离出来作为一个独立部件，就是控制器

设备控制器主要功能：
 接收和识别CPU或通道发来的命令
 实现数据交换,包括设备和控制器间的数据传输
 发现和记录设备及自身的状态信息，供CPU处理
 设备地址识别

设备控制器组成：
 命令寄存器及译码器
 数据寄存器
 状态寄存器
 地址译码器
或

* 设备控制器与处理机的接口
* 设备控制器与设备的接口
* I/O逻辑
  
  <div align=center>
    <img src="../_resources/b7b63b985f95e88fb33f2481303a6b38.png" width=400 />
  </div>

## I/O软件

设计目标：高效率；通用性
问题：
**设备无关性**：与具体物理设备无关
**出错处理**：屏蔽错误，不让高层软件感知
**同步/异步传输**：支持同步与异步
**缓冲技术**：数据处理速率匹配
**独占性外围设备与共享性外围设备**：分配与共享

### 四个层次

* I/O中断处理程序：
* I/O设备驱动程序：I/O 系统高层与设备控制器之间的通信程序。
  主要任务：
  1、接收用户提交的逻辑I/O请求，转化为物理I/O操作，发送给设备控制器，启动设备去执行；
  2、将设备控制器发来的信号传给上层软件
  主要功能：
  设备初始化（检查、预置状态）；执行设备驱动例程（启动设备、通道）；执行中断处理例程（响应中断，执行中断处理程序）
* 独立于设备的操作系统I/O软件：
  提供设备驱动程序统一接口：方便添加设备驱动程序
  设备命名和设备保护：所有设备抽象为文件，用设备文件来表示设备
  提供独立于设备的块大小
  缓冲区管理
  块设备的存储分配
  独占性外围设备的分配和回收
  错误报告
* 用户空间的I/O软件：
  库函数（与应用程序链接）；假脱机技术（虚拟设备）
  
  <div align=center>
    <img src="../_resources/35e1e9ec22a0f2e6f15800536d94dfe4.png" width=400 />
  </div>

## 存储设备

直接存取存储设备：每个物理记录有确定的位置和唯一的地址。信息存取所需的时间几乎不依赖于此信息的位置。如磁盘
柱面号、磁头号、块号

<div align=center>
    <img src="../_resources/cc76e2443b53c7ae72d117a2f5bebb8e.png" width=450 />
</div>

**存储容量＝磁头数×磁道（柱面）数×每道扇区数×每扇区字节数**
固定头磁盘：每条磁道上都有一个读/写磁头，所有的磁头被装入一个磁臂
移动头磁盘：每个盘面仅有一个磁头，被装入一个磁臂中

寻道时间：将磁头从当前位置移到指定磁道所经历的时间
Ts=m*n+s
s：磁盘的启动时间,大约3ms；
m：每移动一条磁道所经历的时间，对一般磁盘：m＝0.3ms，对高速磁盘：m<＝0.1ms；
n：移动的磁道数目

旋转延迟时间：指定扇区移动到磁头下所经历的时间。
Tr=1/2r （平均情况下，需要旋转半圈）
r—磁盘以秒计的旋转速度

传输时间Tt：数据从磁盘读出，或向磁盘写数据所经历的时间
Tt＝b/rN
b：读写的字节数
r：磁盘以秒计的旋转速度
N：一条磁道上的字节数

访问时间Ta=Ts+Tr+Tt=(m*n+s)+1/2r+b/rN

移臂调度算法：
(1)“先来先服务” 算法
(2)“最短查找时间优先”算法：先执行查找时间最短的请求
(3)“扫描”算法：每次沿一个方向移动，扫过所有柱面，遇到最近的I/O请求便进行处理，直到最后一个柱面后，再向相反方向移动回来
(4)“分步扫描”算法：将I／O请求分为长度为N的子队列，按FIFO算法依次处理每个子队列，而每个子队列采用扫描算法，处理完一个后再服务下一个子队列，以避免出现磁臂粘住现象
(5)“电梯调度”算法：发现所移动的方向上不再有请求时立即改变运行方向
(6)“循环扫描”算法：移动臂总是从０柱面至最大号柱面顺序扫描，然后，直接返回０柱面重复进行，归途中不再提供服务，构成一个循环，缩短处理新来请求的最大延迟

## 设备分配

设备独立性：通过其它途径建立逻辑设备和物理设备之间对应关系，
好处：设备分配时的灵活性；易于实现I/O重定向
需要：设备独立性软件；逻辑设备表

设备分为独占设备、共享设备和虚拟设备（虚拟方式是指通过高速的共享设备，把一台慢速的以独占方式工作的物理设备改造成若干台虚拟的同类逻辑设备，这就需要引入SPOOLing技术）三类
先来先服务；优先级高者优先

虚拟设备：
SPOOLing技术：使独占设备变成共享设备的一种技术
利用一道程序，来模拟脱机输入时的外围控制机的功能，再用另一道程序来模拟脱机输出时外围控制机的功能

“井”是用作缓冲的存储区域

<div align=center>
    <img src="../_resources/2d1346a18a7f48355d9f5f3a03110391.png" width=450 />
</div>

输入井中作业状态
 输入状态：
 收容收态：
 执行状态：
 完成状态：

<div align=center>
    <img src="../_resources/8660cc74ba034f64efa49440dc1323a9.png" width=450 />
</div>

SPOOLing系统的特点
 提高I/O的速度
 将独占设备改造为共享设备
 实现虚拟设备的功能

# 一些概念

## 并发并行

**并发**指两个或两个以上的事件或活动在同一时间间隔内发生（不一定同时执行）；
**并行**指两个或两个以上的事件或活动在同一时刻发生（同时执行）。

并行的事件或活动一定是并发的，但反之并发的事件或活动未必是并行的

并发强调的是系统具有处理多个任务的能力，但不一定要同时，并发是一种设计，并行是并发在多处理器下的实现。

## 同步异步、阻塞非阻塞

同步异步是**消息通知**机制（调用者问询/被调用者通知）

<div align="center"><img src="../_resources/e4f758dc1f5239da78e3c6443e853d98.png" width="350" class="jop-noMdConv"></div>

阻塞非阻塞是等待消息通知的**状态**(调用者挂起/不挂起)

<div align="center"><img src="../_resources/34f87c5a16de6f8c1805da4f68d6f165.png" width="350" class="jop-noMdConv"></div>